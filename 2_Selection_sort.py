# 배열 & 연결 리스트 - 여려 개의 항목을 저장하고 싶을 때 사용
# 배열은 임의 접근이 가능하므로 연결 리스트보다 더 많이 사용하는 편
# 기본적으로 컴퓨터는 메모리에 저장할 때마다 공간을 내어주며 각 공간마다 주소값이 있다.

# 배열 - 배열의 모든 원소는 같은 자료형이어야 한다!
# 예시) 로그인 시 사용자 이름 확인
# 영화관 자리 예매와 비슷한 구조: 원하는 인원만큼의 좌석이 한 열에 없으면 다른 열을 찾아본다. (모든 항목은 이웃하는 위치에 저장)
# 장점: 배열 안의 어떤 원소든 바로 읽을 수 있다.
# 단점: 미리 메모리 할당을 많이 했다가 추가할 일이 없다면 메모리 낭비 + 목록의 크기가 10개보다 커지면 어차피 자리 이동해야 함
# Big-O 표현: 읽기 - O(1) / 추가(삽입), 삭제 - O(n)

# 연결 리스트
# 예시) 가계부 앱, 레스토랑 주문 처리 앱
# 어느 곳에나 저장할 수 있으며, 각 메모리 주소들이 하나의 목록으로 연결되는 것이다. (모든 항목은 흩어지지만, 각 항목은 다음 항목의 주소를 저장함)
# 장점: 원소를 추가/삭제하기 빠르다. 아무 곳에나 원소를 넣고, 그 주소를 바로 앞의 원소에 저장해 놓으면 된다.
# 단점: 마지막 원소만을 바로 읽을 수가 없다. 왜냐하면 그 주소를 바로 알 수 없으니까.
# 모든 원소의 값을 한 번에 읽어야 한다면 좋지만, 특정한 원소만 알고 싶다면 연결 리스트는 최악이다.
# Big-O 표현: 읽기 - O(n) / 추가(삽입), 삭제 - O(1)

# Selection sort (선택 정렬)
# 사용 예) 전화번호부의 이름, 여행 날짜, 이메일(최신순)
# 깔끔한 알고리즘이지만 빠르진 않다. 즉, O(n**2)의 실행시간이 걸린다.

# 작은 정수에서 큰 정수 순서로 정렬하는 코드
def findSmallest(arr): # 우선 가장 작은 정수부터 찾는 함수
    smallest = arr[0] # 0번째에 있는 것을 가장 작은 수로 할당
    smallest_index = 0 # 가장 작은 정수의 인덱스를 0으로 할당
    for i in range(1, len(arr)): # 1부터 (배열 길이 -1)까지 i에 순서대로 들어감
        if arr[i] < smallest: # 가장 작은 정수보다 작은 값이 있으면
            smallest = arr[i] # smallest 를 업데이트
            smallest_index = i # 가장 작은 정수가 변경되니까 index 도 업데이트
    return smallest_index

def selectionSort(arr): # 선택 정렬 코드 - 위에 함수를 사용!
    newArr = []
    for i in range(len(arr)): # 0부터 (배열 길이 -1)까지 i에 순서대로 들어감
        smallest = findSmallest(arr) # 배열 내 가장 작은 정수를 찾는 함수를 활용해 가장 작은 정수를 구한 후 변수에 넣어준다.
        newArr.append(arr.pop(smallest)) # 가장 작은 정수를 기존 배열에서 빼고, 새로운 배열에 추가
    return newArr

print(selectionSort([5,3,6,2,10]))
# 동적 프로그래밍 - 어려운 문제를 여러 개의 하위 문제로 쪼개고, 이 하위 문제들을 먼저 해결하는 방법

# 특징
# 모든 동적 프로그래밍은 격자(grid)로부터 시작합니다.
# 모든 동적 프로그램밍의 답안에는 격자가 있다.
# 각자의 각 칸에는 최적화하고자 하는 값을 적는다.
# 각 칸은 원래 문제에 대한 하위 문제이고, 다른 문제를 하위 문제로 가질 수 있다. 그래서 원래의 문제를 어떻게 하위 문제로 나눌 수 있을지 생각해야 한다.
# 꼭 마지막 칸이 정답인 것은 아니며, 격자 전체에서 가장 큰 숫자가 답이다.

# 사용 예시 - 도둑 문제, 여행 일정 최적화 문제, 최장 공통 부분 문자열(유사 단어), DNA 가닥의 유사점 찾기, 철자법 확인, 줄 맞추기 기능
# 어떤 제한 조건이 주어졌을 때 무언가를 최적화하는 경우에 유용

# 예시 1 - 4파운드의 배낭으로 최고가의 물건을 훔치는 도둑
# 목표 - 배낭 채우기 문제에서는 배낭의 크기가 제한 조건이며, 훔칠 물건의 총 가치를 최대화하는 것
# 격자이므로 행, 열로 나누어서 진행한다.
# 행 - 선택할 물건 3가지 / 열 - 1파운드 ~ 4파운드까지의 배낭 크기

# 1행은 기타, 2행은 스테레오, 3행은 노트북
# 1행에서 기타를 넣을지 말지만 고민하면 된다.
# 동적 프로그래밍 문제는 작은 문제부터 시작해서 더 커다란 문제를 풀어나가는 것이다.
# 항상 최종 목표는 무엇인지 기억하면서 작은 문제에 접근해야 한다.

# 새로운 물건이 추가되면 행만 추가해서 풀면 된다. 점진적으로 답을 수정해 나가는 것이다.
# 열의 최대값이 진행할수록 더 작아질 수는 없다. 항상 최대 가치를 저장해놓고 비교하기 때문에 이전의 값보다 더 나빠질 수는 없다.
# 행의 순서가 바뀐다고 해서 결과값이 바뀌진 않는다.
# 물건의 일부만 훔치는 경우라면 탐욕 알고리즘으로 풀어야 하며, 동적 프로그래밍은 물건 하나를 통으로 훔치든가, 아에 안훔치든가 하는 문제뿐!
# 서로 의존적인 물건(한 쪽을 선택할 경우, 다른 한 쪽의 값이 변경되는 문제)이 있는 경우, 동적 프로그래밍으로 풀 수가 없다.
# 기본적으로 최대 두 개의 하위 배낭을 합쳐서 사용할 수 있다. (세 개 이상은 사용 불가)
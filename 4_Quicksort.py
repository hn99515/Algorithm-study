# 분할 정복 - 문제 해결 방법 중에서 가장 유명한 재귀적 기술
# 분할 정복 전략은 재귀적 알고리즘이다.
# 1. 기본 단계를 해결한다. 가능한 가장 간단한 문제여야 한다.
# 2. 문제가 기본 단계로 될 때까지 나누거나 작게 만든다.

def sum(arr): # 더하기 함수
    total = 0
    for x in arr: # 배열에 있는 원소를 x 에 반복 실행
        total += x # total 에 하나씩 넣어서 더해줘
    return total

print(sum([1,2,3,4])) # 재귀에서는 부분적으로 실행된 함수 호출의 상태를 모두 저장한다는 점을 명심하자! = 재귀에서는 상태를 추적

# Quicksort (퀵정렬)
# 선택 정렬보다 훨씬 빠르고 실제로도 자주 사용되는 알고리즘 - 마찬가지로 분할 정복 전략
# 퀵정렬의 성능은 선택한 기준 원소에 크게 의존한다. 주어진 배열이 이미 정렬되어 있는지, 아닌지는 상관없으며 그냥 정렬한다.
# 퀵 정렬은 가장 빠른 정렬 방법 중 하나이고, 분할 정복의 좋은 예

def quicksort(array):
    if len(array) < 2: # 비어있거나 원소가 하나인 배열이 기본 단계다.
        return array # 있는 그대로 반환
    else: # 배열의 원소가 3개 이상인 경우
        pivot = array[0] # pivot은 기준값을 의미
        less = [i for i in array[1:] if i <= pivot] # 기준 값보다 작거나 같은 모든 원소로 이루어진 하위 배열
        greater = [i for i in array[1:] if i > pivot] # 기준 값보다 큰 모든 원소로 이루어진 하위 배열
        return quicksort(less) + [pivot] + quicksort(greater)

print(quicksort([10,5,2,3]))

# 배열 내 원소 정렬 방법 - 퀵정렬
# 1. 기준 원소를 고른다.
# 2. 배열을 기준 원소보다 작은 원소의 배열과 기준 원소보다 큰 원소의 배열로 나눈다 = 2개의 하위 배열로 분류
# 3. 하위 배열에 대해 재귀적으로 퀵정렬을 호출한다.        

# 빅오 표기법 복습
# 선택 정렬 - O(n**2)
# 퀵 정렬 - 평균 O(n*log n), 최악 O(n**2)
# 기존 원소를 전체 배열에서 무작위로 선택한다면 퀵 정렬은 평균적으로 O(n*log n) 실행 시간을 가진다.
# 퀵 정렬과 병합 정렬처럼 가끔은 상수 때문에 차이가 발생하기도 하지만 보통은 상수는 전혀 문제가 되지 않는다.